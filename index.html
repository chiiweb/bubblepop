<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>bubble pop extreme!! ‚ú®</title>
  <link rel="icon" href="data:image/svg+xml,&lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'&gt;&lt;circle cx='50' cy='50' r='45' fill='%23ff6b9d'/&gt;&lt;circle cx='35' cy='35' r='8' fill='%23ffffff' opacity='0.6'/&gt;&lt;/svg&gt;">
  <style>
  :root{ --bg:#ff6b9d; --panel:#ffffff22; --accent:#ffd86b; --muted:rgba(255,255,255,0.85); }
  html,body{ height:100%; margin:0; background: linear-gradient(180deg,#ff6b9d 0%, #c44569 60%, #a29bfe 100%); font-family:'Comic Sans MS',cursive,system-ui; color:white; -webkit-user-select:none; user-select:none; overflow:hidden; font-size:16px;}
  #gameWrap{ position:relative; width:100%; height:100vh; display:flex; align-items:stretch; justify-content:center; }
  canvas{ display:block; background:transparent; width:100%; height:100%; touch-action:none; }
  #hud{ position:absolute; top:12px; left:12px; right:12px; display:flex; gap:8px; justify-content:space-between; pointer-events:none; z-index:30; flex-wrap:wrap;}
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05)); border-radius:16px; padding:10px 14px; font-weight:700; font-size:15px; display:inline-flex; gap:8px; align-items:center; pointer-events:auto; backdrop-filter:blur(8px); box-shadow:0 4px 12px rgba(0,0,0,0.15);}
  #controlsMobile{ position:absolute; bottom:18px; left:0; right:0; display:flex; justify-content:space-between; align-items:center; padding:0 18px; z-index:40; pointer-events:none; }
  .btn{ pointer-events:auto; -webkit-tap-highlight-color: rgba(0,0,0,0); background:rgba(255,255,255,0.15); backdrop-filter:blur(8px); border:3px solid rgba(255,255,255,0.3); color:white; width:68px; height:68px; border-radius:16px; display:flex; align-items:center; justify-content:center; font-size:28px; user-select:none; touch-action:none; transition:transform .08s ease; box-shadow:0 6px 20px rgba(0,0,0,0.2); font-weight:900;}
  .btn:active{ transform: scale(.92); }
  #leftGroup{ display:flex; gap:12px; align-items:center; }
  #rightGroup{ display:flex; gap:12px; align-items:center; }
  #modal{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); background:linear-gradient(180deg, rgba(255,107,157,0.95), rgba(196,69,105,0.95)); backdrop-filter:blur(12px); border-radius:20px; padding:24px; text-align:center; z-index:50; display:none; min-width:280px; max-width:90%; max-height:90vh; overflow-y:auto; box-shadow:0 12px 40px rgba(0,0,0,0.35); border:3px solid rgba(255,255,255,0.3);}
  #modal h2{ margin:0 0 12px 0; font-size:32px; text-shadow:2px 2px 8px rgba(0,0,0,0.3); }
  #modal button{ margin-top:16px; padding:12px 24px; border-radius:16px; border:none; background:linear-gradient(135deg, #ffd86b, #ffaa00); color:#333; font-weight:900; font-size:18px; cursor:pointer; transition:transform 0.1s; box-shadow:0 4px 12px rgba(0,0,0,0.25);}
  #modal button:active{ transform:scale(0.95); }
  #leader{ margin-top:12px; text-align:left; font-size:14px; color:var(--muted); background:rgba(0,0,0,0.15); padding:12px; border-radius:12px; }
  .joystick{
    position:absolute;
    bottom:18px;
    left:18px;
    width:140px;
    height:140px;
    border-radius:50%;
    z-index:41;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
    touch-action:none;
  }
  .joy-base{
    width:100%;
    height:100%;
    background:rgba(255,255,255,0.12);
    backdrop-filter:blur(8px);
    border:3px solid rgba(255,255,255,0.25);
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow:0 6px 20px rgba(0,0,0,0.2);
  }
  .joy-knob{
    width:56px;
    height:56px;
    border-radius:50%;
    background:linear-gradient(135deg,#ffffff,#ffffffaa);
    display:block;
    transform:translate(0,0);
    box-shadow:0 6px 18px rgba(0,0,0,0.35);
    border:2px solid rgba(255,255,255,0.5);
  }
  @media (min-width:900px){ .joystick{ display:none; } .hidden-desktop{ display:none; } }
  @media (max-width:900px){ .hidden-mobile{ display:none; } }
  .topRightControls{ display:flex; gap:8px; align-items:center; pointer-events:auto; flex-wrap:wrap; }
  .topRightControls label{ display:flex; align-items:center; gap:4px; font-size:13px; font-weight:700; cursor:pointer; }
  input[type="checkbox"]{ cursor:pointer; width:18px; height:18px; }
  #username{ width:100%; padding:12px; border-radius:12px; border:3px solid rgba(255,255,255,0.3); background:rgba(255,255,255,0.15); color:white; font-size:16px; font-weight:700; text-align:center; margin:12px 0; outline:none; font-family:inherit;}
  #username::placeholder{ color:rgba(255,255,255,0.6); }
  .star-particle{ position:absolute; pointer-events:none; animation:float-up 2s ease-out forwards; z-index:100; }
  @keyframes float-up{ 0%{opacity:1; transform:translateY(0) scale(1);} 100%{opacity:0; transform:translateY(-100px) scale(0.3);} }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="gameCanvas"></canvas><audio id="gameMusic" src="stargame.mp3" loop="" preload="auto"></audio>
    <div id="hud">
      <div class="panel">
        score: <span id="score">0</span> | <span id="livesDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;">
        <div class="panel">
          level: <span id="level">1</span>
        </div>
        <div class="panel">
          high: <span id="high">0</span>
        </div>
        <div class="panel topRightControls">
          <label>sfx <input id="toggleSound" type="checkbox" checked></label> <label>music <input id="toggleMusic" type="checkbox" checked></label>
        </div>
      </div>
    </div>
    <div id="controlsMobile">
      <div id="leftGroup">
        <button id="btnLeft" class="btn">‚óÄ</button> <button id="btnRight" class="btn">‚ñ∂</button>
      </div>
      <div id="rightGroup">
        <button id="btnAction" class="btn">üéØ</button>
      </div>
    </div>
    <div class="joystick" id="joystick">
      <div class="joy-base" id="joyBase">
        <div class="joy-knob" id="joyKnob"></div>
      </div>
    </div>
    <div id="modal">
      <h2 id="modalTitle">game over!! üíñ</h2>
      <div id="modalText">
        final score: <strong id="modalScore">0</strong>
      </div>
      <div id="leader"></div><button id="btnRestart">play again!! ‚ú®</button>
    </div>
  </div>
  <script>
  // --- CORRECTED PLAYER IMAGE LOADING AND STATE ---
  const playerImage = new Image();
  playerImage.src = 'chiikawa.webp';
  const playerActionImage = new Image();
  playerActionImage.src = 'output-onlinepngtools (12).png';
  let isPlayerAction = false; 

  const rand = (a,b) => a + Math.random()*(b-a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize(){
  const w = window.innerWidth;
  const h = window.innerHeight;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  let state = {
  score:0, lives:3, level:1, running:false, paused:false, high:0, sound:true, music:true,
  username:'', hasUsername:false, combo:0, doublePoints:false, freezeTime:false
  };

  let gameData = {
  leaderboard: [],
  lastCombo: 0
  };

  // Helper function to get the High Score from the leaderboard
  function getHighScore(leaderboard) {
    if (leaderboard.length === 0) return 0;
    return leaderboard.reduce((max, item) => Math.max(max, item.score), 0);
  }

  // Function to load username (using localStorage)
  function loadUsername(){
  try{
    const name = localStorage.getItem('bubble_username');
    if(name){
      state.username = name;
      state.hasUsername = true;
      loadLeaderboard();
      showStartScreen();
    } else {
      loadLeaderboard();
      showUsernameScreen();
    }
  }catch(err){
    console.error('Failed to load username from localStorage:', err);
    loadLeaderboard();
    showUsernameScreen();
  }
  }

  // Function to save username (using localStorage)
  function saveUsername(name){
  try{
    localStorage.setItem('bubble_username', name);
    state.username = name;
    state.hasUsername = true;
    showStartScreen();
  }catch(err){
    console.error('Failed to save username to localStorage:', err);
  }
  }

  // Function to load leaderboard (using localStorage)
  function loadLeaderboard(){
  try{
    const scoresJSON = localStorage.getItem('bubble_leaderboard');
    if(scoresJSON){
      gameData.leaderboard = JSON.parse(scoresJSON);
      gameData.leaderboard.sort((a,b) => b.score - a.score);
      gameData.leaderboard = gameData.leaderboard.slice(0,10);
    } else {
      gameData.leaderboard = [];
    }
    updateHighDisplay();
  }catch(err){
    console.error('Failed to load leaderboard from localStorage:', err);
    gameData.leaderboard = [];
    updateHighDisplay();
  }
  }

  // Function to save score (using localStorage)
  function saveScore(finalScore){
  if(!state.username || finalScore === 0) return;
  try{
    const scoreData = {
      username: state.username,
      score: finalScore,
      level: state.level,
      timestamp: Date.now()
    };
    
    // Load existing, add new, sort, and cap at 10
    const existingScores = JSON.parse(localStorage.getItem('bubble_leaderboard') || '[]');
    existingScores.push(scoreData);
    existingScores.sort((a,b) => b.score - a.score);
    const newLeaderboard = existingScores.slice(0,10);
    
    localStorage.setItem('bubble_leaderboard', JSON.stringify(newLeaderboard));
    
    // Re-load to update internal gameData and display
    loadLeaderboard();
  }catch(err){
    console.error('Failed to save score to localStorage:', err);
  }
  }

  function updateHighDisplay(){
  state.high = getHighScore(gameData.leaderboard);
  document.getElementById('high').textContent = state.high;
  }

  // Music functions using the <audio> element
  const gameMusic = document.getElementById('gameMusic');
  let audioCtx = null; // Keep Web Audio for SFX

  function ensureAudio(){ 
  if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); 
  }

  function startMusic(){
  if(!state.music) return;
  try{
    gameMusic.volume = 0.3; // Set a low volume
    gameMusic.play();
  } catch(e) {
    console.log('Music play failed (user interaction required):', e);
  }
  }

  function stopMusic(){
  gameMusic.pause();
  }

  function tryResumeAudio(){
  try{
    if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    if(state.music) startMusic();
  }catch(e){}
  }

  window.addEventListener('touchstart', tryResumeAudio, {once:true});
  window.addEventListener('mousedown', tryResumeAudio, {once:true});

  const player = { x: window.innerWidth/2, y: window.innerHeight - 90, w:80, h:80, speed:450, vx:0 };
  const items = [];
  const particles = [];
  const obstacles = [];
  let lastSpawn = 0, spawnInterval = 800, lastObstacleSpawn = 0, obstacleInterval = 2000;
  let lastTime = performance.now();
  let comboTimer = null, freezeTimer = null, doubleTimer = null;


  function playBeep(freq=440, dur=0.08, type='sine', vol=0.15){
  if(!state.sound) return;
  ensureAudio();
  try{
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = type; 
    o.frequency.value = freq; 
    g.gain.value = vol;
    o.connect(g); 
    g.connect(audioCtx.destination);
    o.start(); 
    o.stop(audioCtx.currentTime + dur);
  }catch(e){
    console.log('audio error');
  }
  }


  const soundToggle = document.getElementById('toggleSound');
  soundToggle.addEventListener('change', ()=>{ 
  state.sound = soundToggle.checked; 
  if(state.sound) playBeep(600, 0.05);
  });

  const musicToggle = document.getElementById('toggleMusic');
  musicToggle.addEventListener('change', ()=>{
  state.music = musicToggle.checked;
  if(state.music){
    tryResumeAudio();
    startMusic();
  } else stopMusic();
  });

  function spawnBubble(){
  const w = window.innerWidth;
  const x = rand(40, w-40);
  const speedMult = 1 + (state.level - 1) * 0.25;
  items.push({
    id: Math.random().toString(36).slice(2,9),
    x, y:-30,
    vy: rand(80 + state.level*12, 160 + state.level*25) * speedMult,
    size: rand(45, 65),
    color: pick(['#FF6B9D', '#C44569', '#FFA07A', '#98D8C8', '#6C5CE7', '#A29BFE', '#FD79A8', '#FDCB6E', '#FF7675', '#74B9FF']),
    points: Math.floor(rand(1,5)),
    type: 'bubble',
    angle: Math.random()*Math.PI*2,
    rotSpeed: rand(-0.04,0.04)
  });
  }

  function spawnPowerUp(){
  const w = window.innerWidth;
  const types = ['freeze','double','bonus'];
  items.push({
    id: Math.random().toString(36).slice(2,9),
    x: rand(40, w-40),
    y: -30,
    vy: rand(60, 100),
    size: 50,
    type: 'power',
    subtype: pick(types),
    angle: 0,
    rotSpeed: 0.05
  });
  }

  function spawnObstacle(){
  const w = window.innerWidth;
  const types = ['spike','bomb','laser'];
  const type = pick(types);
  const speedMult = 1 + (state.level - 1) * 0.2;
  obstacles.push({
    id: Math.random().toString(36).slice(2,9),
    x: rand(40, w-40),
    y: -30,
    vy: rand(70, 120) * speedMult,
    size: type === 'laser' ? 80 : 55,
    type,
    angle: Math.random()*Math.PI*2,
    rotSpeed: rand(-0.03,0.03)
  });
  }

  function spawnParticles(x,y,color,count=12){
  for(let i=0;i<count;i++){
    particles.push({ 
      x, y, 
      vx:rand(-250,250), 
      vy:rand(-400,-100), 
      life:rand(400,1000), 
      born:performance.now(), 
      size:rand(3,8), 
      color, 
      alpha:1 
    });
  }

  const starDiv = document.createElement('div');
  starDiv.className = 'star-particle';
  starDiv.textContent = '‚ú®';
  starDiv.style.left = x + 'px';
  starDiv.style.top = y + 'px';
  starDiv.style.fontSize = '24px';
  starDiv.style.position = 'absolute';
  document.body.appendChild(starDiv);
  setTimeout(() => starDiv.remove(), 2000);
  }

  function clampCollision(v, min, max) { return Math.max(min, Math.min(max, v)); }

  const keys = {};
  window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft'||e.key==='a') keys.left=true;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=true;
  if(e.key===' '||e.key==='ArrowUp') keys.action=true;
  });
  window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft'||e.key==='a') keys.left=false;
  if(e.key==='ArrowRight'||e.key==='d') keys.right=false;
  if(e.key===' '||e.key==='ArrowUp') keys.action=false;
  });

  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnAction = document.getElementById('btnAction');
  let leftHeld=false,rightHeld=false,actionHeld=false;

  ['touchstart','mousedown'].forEach(ev=>{
  btnLeft.addEventListener(ev,(e)=>{ e.preventDefault(); leftHeld=true; tryResumeAudio(); }, {passive:false});
  btnRight.addEventListener(ev,(e)=>{ e.preventDefault(); rightHeld=true; tryResumeAudio(); }, {passive:false});
  btnAction.addEventListener(ev,(e)=>{ e.preventDefault(); actionHeld=true; tryResumeAudio(); }, {passive:false});
  });
  ['touchend','mouseup','touchcancel','mouseleave'].forEach(ev=>{
  btnLeft.addEventListener(ev, ()=>{ leftHeld=false; }, {passive:true});
  btnRight.addEventListener(ev, ()=>{ rightHeld=false; }, {passive:true});
  btnAction.addEventListener(ev, ()=>{ actionHeld=false; }, {passive:true});
  });

  const joyBase = document.getElementById('joyBase');
  const joyKnob = document.getElementById('joyKnob');
  let joyActive=false, joyCenter={x:0,y:0}, joyId=null;

  function initJoystick(){
  const rect = joyBase.getBoundingClientRect();
  joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
  }
  initJoystick();
  window.addEventListener('resize', initJoystick);

  function setKnobPos(x,y){
  const rect = joyBase.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top + rect.height/2;
  const max = rect.width/2 - 18;
  let dx = x - cx; 
  let dy = y - cy;
  const d = Math.sqrt(dx*dx + dy*dy);
  if(d > max){ dx = dx * (max/d); dy = dy * (max/d); }
  joyKnob.style.transform = `translate(${dx}px, ${dy}px)`;
  const nx = dx / max;
  if(nx < -0.25) { keys.left = true; keys.right = false; } 
  else if(nx > 0.25) { keys.right = true; keys.left = false; } 
  else { keys.left = keys.right = false; }
  }

  function resetKnob(){ 
  joyKnob.style.transform = 'translate(0,0)'; 
  keys.left = false; 
  keys.right = false; 
  }

  joyBase.addEventListener('pointerdown', (e)=>{
  joyActive=true; joyId=e.pointerId; joyBase.setPointerCapture(joyId);
  setKnobPos(e.clientX, e.clientY);
  tryResumeAudio();
  });
  joyBase.addEventListener('pointermove', (e)=>{
  if(!joyActive || e.pointerId !== joyId) return;
  setKnobPos(e.clientX, e.clientY);
  });
  joyBase.addEventListener('pointerup', (e)=>{
  if(e.pointerId !== joyId) return;
  joyActive=false; joyBase.releasePointerCapture(joyId); resetKnob();
  });
  joyBase.addEventListener('pointercancel', (e) => { 
  if(e.pointerId === joyId) { joyActive=false; resetKnob(); } 
  });

  // Update keyboard/button states regularly
  setInterval(()=>{ 
  keys.left = leftHeld || keys.left; 
  keys.right = rightHeld || keys.right; 
  keys.action = actionHeld || keys.action; 
  }, 30);

  function nextLevel(){ 
  state.level++; 
  spawnInterval = Math.max(400, 800 - (state.level-1)*60); 
  obstacleInterval = Math.max(1200, 2000 - (state.level-1)*100);
  playBeep(1200,0.14,'triangle',0.2); 
  spawnParticles(player.x, player.y-20, '#74ffb9', 30); 
  updateUI(); 
  }

  function loseLife(){ 
  state.lives--; 
  state.combo = 0;
  playBeep(180,0.25,'sawtooth',0.28); 
  spawnParticles(player.x, player.y-10, '#ff0000', 24); 
  if(state.lives <= 0) gameOver(); 
  updateUI(); 
  }

  function applyPower(name){
  if(name==='freeze'){ 
    state.freezeTime=true; 
    clearTimeout(freezeTimer);
    freezeTimer = setTimeout(()=>{ state.freezeTime=false; }, 5000);
    playBeep(800,0.14,'sine',0.16); 
  }
  else if(name==='double'){ 
    state.doublePoints=true; 
    clearTimeout(doubleTimer);
    doubleTimer = setTimeout(()=>{ state.doublePoints=false; }, 8000);
    playBeep(1100,0.14,'square',0.16); 
  }
  else if(name==='bonus'){ 
    state.score += 50; 
    playBeep(950,0.12,'triangle',0.18);
  }
  updateUI();
  }

  function updateUI(){ 
  document.getElementById('score').textContent = state.score; 
  const hearts = '‚ù§Ô∏è'.repeat(state.lives);
  const empty = 'üñ§'.repeat(Math.max(0, 3-state.lives));
  document.getElementById('livesDisplay').innerHTML = hearts + empty;
  document.getElementById('level').textContent = state.level; 
  document.getElementById('high').textContent = state.high;
  }

  const modal = document.getElementById('modal');

  function gameOver(){
  state.running = false;
  stopMusic();
  playBeep(200, 0.5, 'sine', 0.2);
  document.getElementById('modalScore').textContent = state.score;
  modal.style.display = 'block';
  saveScore(state.score);
  renderLeader();
  }

  document.getElementById('btnRestart').addEventListener('click', ()=>{ 
  modal.style.display='none'; 
  resetGame(); 
  });

  function renderLeader(){
  const el = document.getElementById('leader');
  el.innerHTML = '<strong>üèÜ top scores!! üèÜ</strong><br>';
  if(gameData.leaderboard.length === 0){
    el.innerHTML += 'no scores yet!! be the first!! ‚ú®';
  } else {
    gameData.leaderboard.slice(0,5).forEach((it,i)=>{ 
      const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':`${i+1}.`;
      el.innerHTML += `${medal} ${it.username} ‚Äî ${it.score} (lvl ${it.level})<br>`; 
    });
  }
  }

  function resetGame(){
  items.length = 0; 
  particles.length = 0;
  obstacles.length = 0;
  state.score = 0; 
  state.lives = 3; 
  state.level = 1; 
  state.running = true; 
  state.paused=false;
  state.combo = 0;
  state.freezeTime = false;
  state.doublePoints = false;
  spawnInterval = 800; 
  obstacleInterval = 2000;
  lastSpawn = 0;
  lastObstacleSpawn = 0;
  player.x = window.innerWidth/2;
  updateUI();
  tryResumeAudio();
  lastTime = performance.now();
  loop(lastTime);
  }

  function showUsernameScreen(){
  modal.innerHTML = `
    <h2>bubble pop!! ‚ú®</h2>
    <p style="margin:8px 0;">enter ur name to start!!</p>
    <input type="text" id="username" placeholder="your name here..." maxlength="20" />
    <button id="btnSubmitName">let's go!! üíñ</button>
  `;
  modal.style.display = 'block';

  const submitBtn = document.getElementById('btnSubmitName');
  const usernameInput = document.getElementById('username');

  submitBtn.addEventListener('click', ()=>{
    const name = usernameInput.value.trim();
    if(name) saveUsername(name);
  });

  usernameInput.addEventListener('keypress', (e)=>{
    if(e.key === 'Enter'){
      const name = usernameInput.value.trim();
      if(name) saveUsername(name);
    }
  });
  }

  function showStartScreen(){
  modal.innerHTML = `
    <h2>hey ${state.username}!! ‚ú®</h2>
    <p style="margin:8px 0;">ready to pop some bubbles?!</p>
    <div style="margin:12px 0; font-size:13px; text-align:left; background:rgba(0,0,0,0.15); padding:10px; border-radius:10px;">
      üí° use ${window.innerWidth > 900 ? 'A/D or Arrow Keys' : 'the joystick'} to move sideways.<br>
      ‚≠ê grab power-ups for bonuses!!<br>
      ‚ö†Ô∏è AVOID obstacles or lose lives!!<br>
      üìà game gets harder every level!!
    </div>
    <button id="btnStart">start game!! üéÆ</button>
    <button id="btnShowLeader" style="margin-top:8px; background:linear-gradient(135deg, #74B9FF, #A29BFE);">leaderboard üèÜ</button>
  `;
  modal.style.display = 'block';

  document.getElementById('btnStart').addEventListener('click', ()=>{
    modal.style.display = 'none';
    resetGame();
  });

  document.getElementById('btnShowLeader').addEventListener('click', ()=>{
    modal.innerHTML = `
      <h2>üèÜ leaderboard üèÜ</h2>
      <div id="leaderList" style="margin:12px 0; font-size:14px; text-align:left; background:rgba(0,0,0,0.15); padding:12px; border-radius:10px; max-height:300px; overflow-y:auto;"></div>
      <button id="btnBackToStart">back ‚ú®</button>
    `;
    
    const leaderList = document.getElementById('leaderList');
    if(gameData.leaderboard.length === 0){
      leaderList.innerHTML = 'no scores yet!! be the first!! ‚ú®';
    } else {
      gameData.leaderboard.forEach((it,i)=>{ 
        const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':`${i+1}.`;
        leaderList.innerHTML += `<div style="margin:6px 0;">${medal} <strong>${it.username}</strong> ‚Äî ${it.score} (level ${it.level})</div>`; 
      });
    }
    
    document.getElementById('btnBackToStart').addEventListener('click', showStartScreen);
  });
  }

  function loop(ts){
  if(!lastTime) lastTime = ts;
  const dt = Math.min(60, ts - lastTime)/1000;
  lastTime = ts;

  if(!state.running){
    return;
  }

  if(!state.paused){ 
    update(dt); 
    render(); 
  } else { 
    render(); 
    ctx.fillStyle='rgba(0,0,0,0.5)'; 
    ctx.fillRect(0,0,window.innerWidth,window.innerHeight);
    ctx.fillStyle='white';
    ctx.font='28px Comic Sans MS';
    ctx.textAlign='center';
    ctx.fillText('paused!! ‚è∏Ô∏è', window.innerWidth/2, window.innerHeight/2);
  }
  requestAnimationFrame(loop);
  }

  function update(dt){
  const now = performance.now();

  // Player movement update:
  let moveDir = 0;
  if(keys.left) moveDir -= 1;
  if(keys.right) moveDir += 1;

  if(moveDir !== 0) {
    player.vx = player.speed * moveDir;
  } else { 
    // Decelerate if no keys are pressed AND joystick is not active
    if (!joyActive) {
        player.vx *= 0.88;
        if(Math.abs(player.vx) < 2) player.vx = 0;
    }
  }

  player.x += player.vx * dt;
  player.x = clamp(player.x, player.w/2, window.innerWidth - player.w/2);
  player.y = window.innerHeight - 90;

  if(!state.freezeTime && now - lastSpawn > spawnInterval){ 
    // Increased power-up spawn probability to make them more common
    if(Math.random() > 0.8) spawnPowerUp();
    else spawnBubble(); 
    lastSpawn = now; 
  }

  if(!state.freezeTime && now - lastObstacleSpawn > obstacleInterval){
    spawnObstacle();
    lastObstacleSpawn = now;
  }

  for(let i=items.length-1;i>=0;i--){
    const it = items[i];
    if(!state.freezeTime) it.y += it.vy * dt;
    it.angle += it.rotSpeed;
    
    // Collision Check: Player vs Item
    const distSq = (player.x - it.x)**2 + (player.y - it.y)**2;
    const radiiSum = (player.w/2) + (it.size/2);
    
    if(distSq < radiiSum**2){
      if(it.type==='bubble'){ 
        const multiplier = (state.combo + 1) * (state.doublePoints ? 2 : 1);
        const points = it.points * multiplier;
        state.score += points; 
        state.combo++;
        spawnParticles(it.x,it.y,it.color,15); 
        playBeep(800 + state.combo * 100, 0.06,'square',0.12); 
        
        // **FIX 1: Action flag set and reset (150ms flash)**
        isPlayerAction = true;
        setTimeout(() => { isPlayerAction = false; }, 150);
        
        clearTimeout(comboTimer);
        comboTimer = setTimeout(()=>{ state.combo = 0; updateUI(); }, 1500);
        
        // **FIX 2: Corrected Level-Up Check**
        // A simple progression: requires 250 * current level to advance
        const levelGoal = 250 * state.level;
        if(state.score >= levelGoal) nextLevel();
      }
      else if(it.type==='power'){ 
        applyPower(it.subtype); 
        spawnParticles(it.x,it.y,'#FFD700',18);

        // **FIX 1: Action flag set and reset for power-ups**
        isPlayerAction = true;
        setTimeout(() => { isPlayerAction = false; }, 150);
      }
      items.splice(i,1);
      updateUI();
      continue;
    }
    
    if(it.y - it.size > window.innerHeight + 40){ 
      if(it.type === 'bubble'){
        loseLife();
      }
      items.splice(i,1); 
    }
  }

  for(let i=obstacles.length-1;i>=0;i--){
    const ob = obstacles[i];
    if(!state.freezeTime) ob.y += ob.vy * dt;
    ob.angle += ob.rotSpeed;
    
    // Collision Check: Player vs Obstacle
    const distSq = (player.x - ob.x)**2 + (player.y - ob.y)**2;
    const radiiSum = (player.w/2) + (ob.size/2);

    if(distSq < radiiSum**2){
      loseLife();
      spawnParticles(ob.x, ob.y, '#FF0000', 20);
      obstacles.splice(i,1);
      continue;
    }
    
    if(ob.y - ob.size > window.innerHeight + 40){ 
      obstacles.splice(i,1); 
    }
  }

  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i]; 
    const age = performance.now() - p.born;
    if(age > p.life){ 
      particles.splice(i,1); 
      continue; 
    }
    const t = age / p.life;
    p.vy += 800 * dt; 
    p.x += p.vx * dt; 
    p.y += p.vy * dt; 
    p.alpha = 1 - t;
  }
  }

  function clear(){
  ctx.clearRect(0,0,window.innerWidth,window.innerHeight);
  const grd = ctx.createLinearGradient(0,0,0,window.innerHeight);
  grd.addColorStop(0,'rgba(255,107,157,0.3)'); 
  grd.addColorStop(1,'rgba(162,155,254,0.2)');
  ctx.fillStyle = grd; 
  ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

  for(let i=0;i<40;i++){ 
    ctx.globalAlpha = 0.03 + (i%8)*0.008; 
    const sx = (i*123 + (performance.now()/50 % window.innerWidth)) % window.innerWidth; 
    const sy = (i*67 + (performance.now()/90 % window.innerHeight)) % window.innerHeight; 
    ctx.fillStyle='rgba(255,255,255,0.6)'; 
    ctx.fillRect(sx, sy, 2, 2); 
  }
  ctx.globalAlpha = 1;
  }

  // --- CORRECTED drawPlayer FUNCTION ---
  function drawPlayer(){
  ctx.save();
  ctx.translate(player.x, player.y);

  // Determine which image to draw
  const currentImage = isPlayerAction ? playerActionImage : playerImage;

  // Draw the image centered on the player's position
  // Adjust width/height as needed for scale. player.w/player.h are currently 80.
  // We'll scale it slightly to fit the original player size.
  const scale = player.w / currentImage.width;
  const drawWidth = currentImage.width * scale;
  const drawHeight = currentImage.height * scale;

  // Ensure image is loaded before drawing
  if (currentImage.complete) {
    ctx.drawImage(currentImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
  } else {
    // Fallback if image not loaded (using original simple drawing logic)
    ctx.beginPath();
    ctx.arc(0, 0, player.w/2, 0, Math.PI*2);
    const grd = ctx.createRadialGradient(0, -10, 10, 0, 0, player.w/2);
    grd.addColorStop(0, '#ffffff');
    grd.addColorStop(0.5, '#74B9FF');
    grd.addColorStop(1, '#A29BFE');
    ctx.fillStyle = grd;
    ctx.fill();
    
    // Fallback eyes/mouth
    ctx.beginPath();
    ctx.arc(-12, -8, 8, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(-12, -8, 4, 0, Math.PI*2);
    ctx.fillStyle = '#333333';
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(12, -8, 8, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(12, -8, 4, 0, Math.PI*2);
    ctx.fillStyle = '#333333';
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(0, 8, 16, 0, Math.PI);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  ctx.restore();

  // Draw power-up effects (outside of translation/rotation block)
  if(state.freezeTime){ 
    ctx.beginPath(); 
    ctx.strokeStyle='#74ffb9'; 
    ctx.lineWidth=3; 
    ctx.arc(player.x, player.y, player.w/2 + 8, 0, Math.PI*2); 
    ctx.stroke(); 
  }
  if(state.doublePoints){
    ctx.beginPath(); 
    ctx.strokeStyle='#FFD86B'; 
    ctx.lineWidth=3; 
    ctx.arc(player.x, player.y, player.w/2 + 14, 0, Math.PI*2); 
    ctx.stroke();
  }
  }
  // --- END CORRECTED drawPlayer FUNCTION ---

  function drawItems(){
  for(const it of items){
    ctx.save(); 
    ctx.translate(it.x, it.y); 
    ctx.rotate(it.angle);
    
    if(it.type === 'bubble'){ 
      ctx.beginPath();
      ctx.arc(0, 0, it.size/2, 0, Math.PI*2);
      const grd = ctx.createRadialGradient(-it.size/4, -it.size/4, 0, 0, 0, it.size/2);
      grd.addColorStop(0, it.color + 'dd');
      grd.addColorStop(1, it.color);
      ctx.fillStyle = grd;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      ctx.beginPath();
      ctx.arc(-it.size/5, -it.size/5, it.size/8, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.fill();
      
      ctx.fillStyle = '#ffffff';
      ctx.font = `bold ${Math.floor(it.size*0.4)}px Comic Sans MS`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(it.points, 0, 0);
    }
    else if(it.type === 'power'){ 
      ctx.beginPath();
      ctx.arc(0, 0, it.size/2, 0, Math.PI*2);
      const powerColor = it.subtype === 'freeze' ? '#667eea' : 
                         it.subtype === 'double' ? '#f093fb' : '#ffecd2';
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, it.size/2);
      grd.addColorStop(0, powerColor);
      grd.addColorStop(1, powerColor + '88');
      ctx.fillStyle = grd;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      ctx.fillStyle = '#ffffff';
      ctx.font = `${Math.floor(it.size*0.5)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const icon = it.subtype === 'freeze' ? '‚è∞' : 
                   it.subtype === 'double' ? '‚ö°' : '‚≠ê';
      ctx.fillText(icon, 0, 0);
    }
    ctx.restore();
  }
  }

  function drawObstacles(){
  for(const ob of obstacles){
    ctx.save();
    ctx.translate(ob.x, ob.y);
    ctx.rotate(ob.angle);
    
    if(ob.type === 'bomb'){
      ctx.beginPath();
      ctx.arc(0, 0, ob.size/2, 0, Math.PI*2);
      const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, ob.size/2);
      grd.addColorStop(0, '#ff0000');
      grd.addColorStop(1, '#8b0000');
      ctx.fillStyle = grd;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,0,0,0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = '#ffffff';
      ctx.font = `${Math.floor(ob.size*0.6)}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('üí£', 0, 0);
    }
    else if(ob.type === 'spike'){
      ctx.fillStyle = '#2b2b2b';
      ctx.beginPath();
      for(let i=0;i<8;i++){
        const angle = (Math.PI * 2 * i) / 8;
        const x = Math.cos(angle) * ob.size/2;
        const y = Math.sin(angle) * ob.size/2;
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    else if(ob.type === 'laser'){
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(-ob.size/2, -4, ob.size, 8);
      ctx.strokeStyle = '#ffaaaa';
      ctx.lineWidth = 2;
      ctx.strokeRect(-ob.size/2, -4, ob.size, 8);
      
      ctx.fillStyle = '#ffffff';
      ctx.font = `14px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('‚ö°', 0, 0);
    }
    ctx.restore();
  }
  }

  function drawParticles(){ 
  for(const p of particles){ 
    ctx.globalAlpha = p.alpha || 1; 
    ctx.fillStyle = p.color; 
    ctx.beginPath(); 
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); 
    ctx.fill(); 
  } 
  ctx.globalAlpha = 1; 
  }

  function drawCombo(){
  if(state.combo > 0){
    ctx.save();
    ctx.font = 'bold 24px Comic Sans MS';
    ctx.fillStyle = '#FFD86B';
    ctx.strokeStyle = '#FF6B9D';
    ctx.lineWidth = 3;
    ctx.textAlign = 'center';
    const text = `COMBO x${state.combo + 1}!!`;
    ctx.strokeText(text, window.innerWidth/2, 80);
    ctx.fillText(text, window.innerWidth/2, 80);
    ctx.restore();
  }
  }

  function render(){ 
  clear(); 
  drawItems(); 
  drawObstacles();
  drawPlayer(); 
  drawParticles();
  drawCombo();
  }

  loadUsername();

  document.addEventListener('visibilitychange', ()=>{ 
  if(document.hidden && state.running) state.paused = true; 
  });

  function adaptUI(){ 
  const mobileControls = document.getElementById('controlsMobile'); 
  const joystick = document.getElementById('joystick'); 
  if(window.innerWidth > 900){ 
    mobileControls.style.display='none'; 
    joystick.style.display='none'; 
  } else { 
    mobileControls.style.display='flex'; 
    joystick.style.display='flex'; 
  } 
  // Update start screen instructions based on device
  const startModal = document.querySelector('#modal h2');
  if(startModal && startModal.textContent.includes('hey')) {
     showStartScreen(); 
  }
  }
  window.addEventListener('resize', adaptUI); 
  adaptUI();
  </script>
</body>
</html>
